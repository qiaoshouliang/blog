直接看题： **给定一个自然数 n，然后求出前 n 个自然数的和 sum。( n > 0 )**

> 如：
> n = 3，则 sum = 1 + 2 + 3 = 6
> n = 5，则 sum = 1 + 2 + 3 + 4 + 5 = 15



然后给出如下三种解法。 方法一

```java
private int fun1(int n) {
  return n * (n - 1) / 2;
}
```

方法二

```java
private static int fun2(int n) {
    int sum = 0;
    for (int i = 1; i <= n; i++) {
        sum = sum + i;
    }
    return sum;
}
```

方法三

```java
private static int fun3(int n) {
    int sum = 0;
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= i; j++) {
            sum++;
        }
    }
    return sum;
}
```

上述给出的三种方法都可满足给定的需求，但是如果需要在这三个方法中选出一个最优解，那就需要使用时间复杂度来衡量他们了。

> 如果某些行代码执行的时间不受用户输入影响，将该代码的执行时间记录为 **常数时间**，用 C 表示

在 fun1 中，方法体就一行代码。且该行代码的执行时间不受用户输入影响，即使入参 n 的值为 1000，10000.... fun1 的执行时间依然不变。所以可以把 fun1 的时间复杂度记为 C。

在 fun2 中，是有一些局部变量和一个 for 循环组成，int sum = 0; int i = 0; return sum; 这些代码并不会受输入参数 n 的影响，所以我们记录为 3C。而 for 循环中的条件判断，和 for 循环中的方法体都会执行 n 次（受入参 n 的影响），这部分的时间记录为 2n。所以 fun2 最后的时间复杂度为 3C + 2n。

在 fun3 是有一些局部变量和两个 for 循环构成，且这两个 for 循环是嵌套关系。外层 for 循环的时间复杂度为 n，内存 for 循环加上循环体的执行的之间复杂度为 2n。对于这中嵌套关系的循环，复杂度之间是相乘的。及 n * 2n = 2n²。再加上 3 个变量的声明的事件复杂度 3C。所以 fun3 的渐进时间复杂度为 2n² + 3C。

通常，在评估时间复杂度的时候，我们会忽略掉两个部分，一个部分是**低阶**，另一个部分是**常数阶**。因为一般在评估时间复杂度的时候都是评估的最坏的时间复杂度，所以这两部分可以直接忽略掉。对应到上述三个方法中:

fun1 = C = O(1)

fun2 = 3C + 2n = O(n)

fun3 = 2n² + 3C = O(n²)

如果 for 循环中是简单的线性递增（递减）且其上限不是一个常数的情况下，那么可以认为当前的循环的时间复杂度为 O(n)

```text
public void method1(int n){
    for(int i = 0; i < n; i++){
     // do O(1)
    }
} 
```

上述方法 method1 中的 for 循环的时间复杂就是 O(n)。

```java
public void method2(int n) {
    for(int i = 0; i < 10000; i++) {
     // do O(1)
    }
}
```

此时，method2 方法中也有一个 for 循环，但是这个循环的执行时间并不受输入参数 n 的影响，所以，method2 的时间复杂度为 O(1)。

知道了上述三个方法的渐进时间复杂度，下面来看看他们的增长顺序：

> 假设有 f(n) = 2n² + n + 6 ; g(n) = 100n + 3，那么忽略完它们的低阶及常数阶之后则 f(n) = n²，g(n) = n。 由此我们可以判断 f(n) 的增长顺序是要高于 g(n) 的。也就是 f(n) 的时间复杂度比 g(n) 要高。

下面是上述是三种方法各自时间复杂度的图示：

> 横坐标 n 表示用户输入的数据量 纵坐标 t 表示计算消耗的时间

![img](https://picb.zhimg.com/80/v2-54688f392df9c68f11401f1bac527aaa_720w.jpg)



从图可以看出，增长顺序由低到高为 O(1) < O(n) < O(n²)。算法的性能排序是 fun1 > fun2 > fun3。

我们在上面表示算法的复杂度时候用的渐进符号是大 O 符号，其实还有两种渐进符号表示复杂度的，它们分别是 Θ 和 Ω 符号 。

O 渐进符号定义了**一个算法的上限**，也就是我们说的最坏时间复杂度。例如，插入排序，最佳的情况下的时间复杂度是 O(n)，而最坏的情况是 O(n²)，所以我们可以说插入排序的事件复杂度是 O(n²)

Θ 渐进符号表示的是**一个算法从上限到下限的时间复杂度**。一个简单的方法获取 Θ 渐进表达式为去掉低阶以及忽略常数阶。例如：`3n³ + 6n² + 6000 = Θ(n³)`，而如果使用Θ表示插入排序的事件复杂度，则需要如下：

1. 插入排序的最坏时间复杂度为 Θ(n²)
2. 插入排序的最佳时间复杂度为 Θ(n)

Ω 渐进符号表示**一个算法的下限**，也就是我们说的最佳时间复杂度。如果我们需要就拿一个算法的最佳时间复杂度的时候，Ω会被用到。Ω 符号是这三个渐进符号中使用最少的。

**下面我们来分下各种循环的时间复杂度**。

O(1): 如果一个方法或者语句中不包含循环，递归，或者没有调用其他时间复杂度为非常数的情况下，这个方法的时间复杂度被认为是 O(1)。 注意，**一个循环或者递归如果执行的次数为常数级。则它们的时间复杂度依然被认为是 O(1)**，如下代码中的循环的时间复杂度就是 O(1)：

```java
int c = 100;
for (int i = 1; i <= c; i++){
 // 执行 O(1) 的循环体
}
```

O(n): 如果循环是以一个恒定的值递增/递减，则循环的时间复杂度就可以记为 O(n)

> c 是一个常数；n 为用户输入

```java
for (int i = 0; i < n; i = i+c){
 // do O(1)
}
```

上述 for 循环中，n 是用户输入，c 是一个常量，我们假设 n = 10; c = 2; 变量 i 的值依次递增为：0，2，4，6，8；执行次数为 n/c；记为 O(n/c)，最后忽略掉常数阶c，则为 O(n)。

O(n²)：如果一个方法中包含两个嵌套关系的循环，且循环里面的循环变量都是以一个恒定的值递增/递减。那么这个方法的时间复杂度可以记为 O(n²)，如下：

```java
// n 表示用户输入；c 表示常数
for (int i = 1; i <= n; i += c) {
 for (int k = 1; k <= n; k += c) {
     // do O(1)
    }
}
```

O(Logn): 如果循环中的循环变量除以/乘以 一个常数，那么该循环的事件复杂度可以记为 O(Logn)

```java
// n 表示用户输入；c 表示常数
for (int i = 0; i <= n; i *= c) {
 // do O(1)
}
```

我们假设 n = 32; c = 2；则循环变量 i 的值依次为：0，2，4，8，16，32 ......

我们可以把 i 的值记为 1 , C , C² , C³ ...... C^k-1

接着就是 C^k-1 <= n，我们求出 k 的值，这里是一个对数运算，算出来就是 k < Logc^n+1 (Log 以 C 为底 n+1 的对数)，接着我们忽略掉 **Logc^n+1 中的常数阶 c 和 1。最终的结果就是 Logn。**

> 对数计算小常识：
> 假设 a^x = N ，我们知道 a = 2，x = 3, 那么 N 就等于 8，这是一个指数运算，求的是 N 。
> 对数运算就是已知 a 和 N 求 x，如 2^x = 8, 我们一眼就能看出 x = 3。写作 x = Log2^8 (Log 以 2 为底 8 的对数)

**例如，二分查找的时间复杂度就是 O(Logn)**

O(LogLogn): 如果一个 for 循环中的循环变按照指数级的递增或者递减，那么，这个循环的事件负责度可以记为 O(LogLogn)。

```java
// n 表示用户输入；c 表示常数
// pow 表示 i^c
for (int i = 2; i < n; i = Math.pow(i, c)) {
 // do O(1)
}
```

**上述代码中，循环变量 i 的初始值为 2，i 的值变化如下及循环的时间复杂度计算如下：**

**![img](https://pic3.zhimg.com/80/v2-3fb3021318300fc1da11cb1838aa3b5d_720w.jpg)**

我们最终忽略低阶及常数阶之后得到的渐进时间复杂度为 O(LogLogn)

O(nLogn): 下面我们来看一个渐进时间复杂度为 O(nLogn) 的例子。

```java
public void fun(int n) {
 for (int i = 0; i < n; i++ ){
     for (int k = 1; k < n; k = k*2){
         // do O(1)
        }
    }
}
```

**上述方法 fun 中，包含了两个嵌套的 for 循环，外层 for 循环的事件复杂度为 O(n); 内层 for 循环的事件复杂度为 O(logn)。** 在计算嵌套 for 循环的时候，需要将每一层的时间复杂度相乘。则有：O(n) * O(logn)，所以上述方法 fun 的渐进时间复杂度为O(nlogn)。

下面看几个例子

```java
public void demo1(int n) {
 for (int i = 0; i < n; i++) {
     // do O(1)
    }
    
    for (int i = 1; i < n; i = i * 2) {
     // do O(1)
    }
    
    for (int i = 0; i < 100; i++) {
     // do O(1)
    }
}
```

**上述方法 demo1 中，包含了三个并列的 for 循环，现在我们很容易就能判断出第一个 for 循环的时间复杂度为 O(n); 第二个 for 循环的时间复杂度为 O(logn); 而第三个 for 循环的时间复杂度为 O(1), 因为它的执行次数并不受用户输入的影响。**

**对于并列的 for 循环，我们需要把每个 for 循环的时间复杂度相加，所以方法 demo1的事件复杂度为：O(n) + O(logn) + O(1) 。**

**那么我们忽略掉低阶 O(logn) 和常数阶 O(1)，最后得出方法 demo1的时间复杂度为 O(n)。**

```java
public void demo2(int n) {
 for (int i = 0; i < n; i++) {
     for (int j = 1; j < n; j = j * 2){
         // do O(1)
        }
    }
    
    for (int i = 0; i < n; i++) {
     for(int j = 1; j < n; j++) {
         // do O(1)
        }
    }
}
```

分析：demo2 中，有两个并列型大的 for 循环，每一个 for 循环都是一个嵌套型的循环。第一个大的 for 循环的时间复杂度为 O(nlogn)；第二个大的 for 循环的时间复杂度为 O(n²)。demo2 的时间复杂度为 f(n) = O(nlogn) + O(n²) 。省略低阶 O(nlogn) 之后，demo2 的渐进时间复杂度为 O(n²)。

> 注意：对于一个方法中包含多个 for 循环的情况，如果它们是并列的，则该方法的时间复杂度为多个 for 循环的时间复杂度的和； 如果是嵌套的，则该方法的时间复杂度为多个 for 循环的时间复杂度的乘积。

下面再看一个例子

```java
// c 表示一个常数
public void demo3(int m, int n) {
 for(int i = 1; i <= m; i += c) {
     // do O(1)
    }
    
    for(int i = 1; i <= n; i += c) {
     // do O(1)
    }
}
```

**对于 demo3 中，它的时间复杂度为 f(n) = O(m) + O(n) = O(m + n)；如果 m == n，则 f(n) = O(2n) = O(n)。**



好了，上面分别讲述了 O(1), O(n), O(n²)，O(logn), O(nlogn) 等情况，如有错误，还望指出。